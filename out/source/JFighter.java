/* autogenerated by Processing revision 1277 on 2022-01-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class JFighter extends PApplet {

 //graphics lib
int stage = 0; //variable to control the state of the game (menu, gameplay, pause or exiting)
Menu menu; 
Player player;
Background background;
Enemy enemy;
Bullet bullet;

 public void setup() {
    /* size commented out by preprocessor */;
    /* smooth commented out by preprocessor */;
    menu = new Menu("/data/hills.png"); //main menu's class
    player = new Player(50, 435, "/data/player.png"); //players class
    background = new Background("/data/big-hills2.png", 0); //background class
    enemy = new Enemy("/data/enemy_red.png", random(2, 5)); //enemy class
    bullet = new Bullet("/data/bullet.png", 15, 50);
}

 public void draw() {
    if (stage == 0) {
        menu.drawBackground();
        menu.drawButtons();
    }
    else if (stage == 1) {
        background.drawScene();
        player.drawPlayer();
        bullet.shootBullet();
        enemy.spawnEnemy();
    }
    else if (stage == 2) {
        exit();
    }
}

//validates the user input
 public void keyPressed() {
    player.pressed((key == 'w' || key == 'W'), (key == 's' || key == 'S'), (key == 'a' || key == 'A'), (key == 'd' || key == 'D'));
}

 public void keyReleased() {
    player.released((key == 'w' || key == 'W'), (key == 's' || key == 'S'), (key == 'a' || key == 'A'), (key == 'd' || key == 'D'));
    bullet.released((key == ' '));
}
class Background {
    //vars
    PImage bg, mg;
    float posX, posY, scrollOffset;

    //constructor
    Background(String b, float x) {
        scrollOffset = 1.8f;
        bg = loadImage(b);

        //default x for the hills
        posX = x;
    }

     public void drawScene() {
        //draws the background image
        image(bg, posX, 0);
        //debug 
        //println("posX: " + posX + " posY: " + posY + "\n");
        scrollHills();
    }

     public void scrollHills() {
        //while the player moves forward
        if (player.xSpeed > 0) {
            //this creates the illusion of movement by moving the middleground faster than the player
            posX -= player.xSpeed * scrollOffset;

            //this loops the image (the image width is 4800 it's basicly 3 pictures in one), by resetting it's x position once the player hits the limit
            if (posX <= -3200) posX = 0;
        }
    }
}
class Bullet {
    //vars
    PImage bullet;
    float posX, posY, speed, damage;
    boolean shoot, stop;

    //constructor
    Bullet(String b, float s, float d) {
        bullet = loadImage(b);
        speed = s;
        damage = d;
    }

     public void shootBullet() {
        if (shoot == true) {
            calcPosition();
            drawBullet();
            moveBullet();
        }
    }
    //this draws the bullet to the canvas
     public void drawBullet() {
        image(bullet, posX, posY, width/20, height/20);
    }

    //validates user input and acts as a switch
     public void released(boolean space) {
        if (space) shoot = true;
    }

    //method to move the bullet
     public void moveBullet() {
        posX += speed;
    }

    /*
    this method calculates the starting position of the bullet using the players positions and sizes
    the stop variable acts as a switch so the bullet's posX and posY doesn't update with the player thus allowing
    the bullet to only be affected by the moveBullet() method.
    */
     public void calcPosition() {
        if (stop == false) {
            posX = player.posX + 90;
            posY = player.posY + 30;
            stop = true;
        }
    }
}
class Button {
    //vars
    float posX, posY;
    int tSize;
    String text;
    int tColor;

    //constructor
    Button(float x, float y, String t) {
        posX = x;
        posY = y;
        text = t;
        //text color and text size
        tColor = color(255);
        tSize = 100;
    }

    //method to draw the text
     public void drawText() {
        textSize(tSize);

        //changes the color of the text on mouse hover using the text's X and Y positions
        if (mouseX > posX && mouseX < posX + 210 && mouseY < posY && mouseY > posY - 80) 
            fill(136,155,192);
        else fill
            (tColor);

        text(text, posX, posY);
    }

     public void mouseInteraction() {
        //changes the value of the stage variable if the button is pressed, thus playing the game
        if (mouseX > menu.play.posX && mouseX < menu.play.posX + 210 && mouseY < menu.play.posY && mouseY > menu.play.posY - 80 && mousePressed == true) {
            stage = 1;
        }        
        //changes the value of the stage variable if the button is pressed, thus quitting the game
        if (mouseX > menu.quit.posX && mouseX < menu.quit.posX + 210 && mouseY < menu.quit.posY && mouseY > menu.quit.posY - 80 && mousePressed == true) {
            stage = 2;
        }
        
    }
}
/*
What I did here was basicly defaulting the enemy's X position and re-randomizing it's Y position once it dies,
this allows me to "re-use" the enemy. I chose this approach because I think it's simple and good performance wise
*/
class Enemy {
    //vars
    PImage enemy;
    float posX, posY, speed, health;

    //constructor
    Enemy(String x, float s) {
        enemy = loadImage(x);
        posX = 1700; //spawn outside the canvas so it animates the entrance
        posY = random(0, height - height/14 - 2); //height/12 because of the size of the sprite
        speed = s; //i decided to pass the speed in the constructor so i can increase the difficulty over time
        health = 100.0f;
    }

     public void spawnEnemy() {
        spawn();
        move();
    }

     public void spawn() {
        image(enemy, posX, posY, width/14, height/14);
    }

     public void move() {
        //this validates the enemy's health and its X position 
        if (posX >= -(width/14 + 4) && health > 0) {
            posX -= speed;
        }
        else {
            //this code block is responsible for the repetition of the object 
            posX = 1700;
            posY = random(0, height - height/14 - 4);
        }
    }
}
class Menu {
    //vars
    Button play, quit;
    PImage bg;

    //constructor
    Menu(String z) {
        //play button
        play = new Button(700, 200, "PLAY");
        //quit button
        quit = new Button(700, 825, "QUIT");
        //loads background image
        bg = loadImage(z);
    }

     public void drawBackground() {
        //load background image
        background(bg);
    }

     public void drawButtons() {
        play.drawText();
        play.mouseInteraction();
        quit.drawText();
        quit.mouseInteraction();
    }
}
//note: some snippets of this code were studied and extracted from: https://stackoverflow.com/questions/60307773/smooth-movement-in-processing
class Player {
    float posX, posY, xSpeed, ySpeed, speedLimit, acceleration;
    boolean move_up = false, move_down = false, move_left = false, move_right = false;
    PImage plane;

    //constructor
    Player(float x, float y, String z) {
        //player pos and speed
        posX = x;
        posY = y;
        ySpeed = 0.0f; //DO NOT CHANGE, this isn't what you think it is 
        xSpeed = 0.0f; //DO NOT CHANGE, this isn't what you think it is
        //speed limit and acceleration for the movement
        speedLimit = 5.0f;
        acceleration = 0.25f;
        //loads the player's sprite
        plane = loadImage(z);
    }

    //this method draws the image to the screen
     public void drawPlayer() {
        image(plane, posX, posY, width/11, height/11);
        //player debug
        println("posX: " + posX + " posY: " + posY + "\n" + "speed: " + xSpeed + "\n");
        move();
    }

   //this method receives the pressed input and acts as a switch for the booleans 
     public void pressed(boolean up, boolean down, boolean left, boolean right) {
        if (up) move_up   = true;
        if (down) move_down = true;
        if (left) move_left   = true;
        if (right) move_right = true;
    }

    //this method receives the released input and acts as a switch for the booleans 
     public void released(boolean up, boolean down, boolean left, boolean right) {
        if (up) move_up   = false;
        if (down) move_down = false;
        if (left) move_left   = false;
        if (right) move_right = false;
    }

     public void move() {
        /*
        the use of acceleration helps creating a smoother movement
        the value of the speed when the key is released multiplies by 0.95 so it creates a smooth stoppage slowly reducing the speed
        */
        if (!move_up && !move_down) ySpeed *= 0.95f;
        if (move_up) ySpeed -= acceleration;
        if (move_down) ySpeed += acceleration;

        //limits the speed 
        ySpeed = max(-(speedLimit), min(speedLimit, ySpeed));
        posY += ySpeed;

        //left and right
        if (!move_left && !move_right) xSpeed *= 0.95f;
        if (move_left) xSpeed -= acceleration;
        if (move_right) xSpeed += acceleration;
        
        xSpeed = max(-(speedLimit), min(speedLimit, xSpeed));
        posX += xSpeed;

        //this blocks the player from exiting the canvas
        if (posY < 2) posY = 2;
        if (posY > height - height/11 - 2) posY = height - height/11 - 2;

        if (posX < 2) posX = 2;
        if (posX > width - width/2 - 100) posX = width - width/2 - 100;
    }
}


  public void settings() { size(1600, 870);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "JFighter" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
