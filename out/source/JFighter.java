/* autogenerated by Processing revision 1277 on 2022-01-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class JFighter extends PApplet {

 //graphics lib
int stage = 0; //variable to control the state of the game (menu, gameplay, pause or exiting)
public int score = 0;
Menu menu; 
Player player;
Background background;
public Enemy[] enemies;
public ArrayList<Bullet> bullets = new ArrayList<Bullet>();
Collider collider;
Points points;
GameOver gameover;

 public void setup() {
    /* size commented out by preprocessor */;
    /* smooth commented out by preprocessor */;
    textAlign(CENTER);
    menu = new Menu("/data/hills.png"); //main menu's class
    player = new Player(50, 435, "/data/player.png"); //players class
    background = new Background("/data/big-hills2.png", 0); //background class
    enemies = new Enemy[12];
    for (int i = 0; i < enemies.length; i++) {
        enemies[i] = new Enemy("/data/enemy_red.png", 4, random(1700, 2300)); //enemy class
    }
    collider = new Collider(45, 75); //minDistance
    points = new Points("/data/ThaleahFat.ttf", width/2, 50, 64);
    gameover = new GameOver("/data/ThaleahFat.ttf", width/2, height/2, 128);
}

 public void draw() {
    if (stage == 0) {
        menu.drawBackground();
        menu.drawButtons();
    }
    else if (stage == 1) {
        background.drawScene();
        player.drawPlayer();
        //loops trought the list of bullets and updates them
        for (Bullet bullet : bullets) {
            bullet.shootBullet();
        }
        for (Enemy enemy : enemies) {
            enemy.spawnEnemy();
        }
        collider.runColliders();
        points.displayScore();
    }
    else if (stage == 2) {
        exit();
    }
    else if (stage == 3) {
        menu.drawBackground();
        gameover.displayGameOver();
    }
}

//validates the user input
 public void keyPressed() {
    player.pressed((key == 'w' || key == 'W'), (key == 's' || key == 'S'), (key == 'a' || key == 'A'), (key == 'd' || key == 'D'));
    //each time the user presses space a new bullet is added to the array :)
    if (key == ' ') bullets.add(new Bullet("/data/bullet.png", 25, 100));
}

 public void keyReleased() {
    player.released((key == 'w' || key == 'W'), (key == 's' || key == 'S'), (key == 'a' || key == 'A'), (key == 'd' || key == 'D'));
}
class Background {
    //vars
    PImage bg, mg;
    float posX, posY, scrollOffset;

    //constructor
    Background(String b, float x) {
        scrollOffset = 1.8f;
        bg = loadImage(b);

        //default x for the hills
        posX = x;
    }

     public void drawScene() {
        //draws the background image
        image(bg, posX, 0);
        //debug 
        //println("posX: " + posX + " posY: " + posY + "\n");
        //metodo desativado porque a velocidade dos inimigos fica super esquesita :(
        //scrollHills();
    }

     public void scrollHills() {
        //while the player moves forward
        if (player.xSpeed > 0) {
            //this creates the illusion of movement by moving the middleground faster than the player
            posX -= player.xSpeed * scrollOffset;

            //this loops the image (the image width is 4800 it's basicly 3 pictures in one), by resetting it's x position once the player hits the limit
            if (posX <= -3200) posX = 0;
        }
    }
}
class Bullet {
    //vars
    PImage bullet;
    float posX, posY, speed, damage;
    boolean stop;

    //constructor
    Bullet(String b, float s, float d) {
        bullet = loadImage(b);
        speed = s;
        damage = d;
    }

     public void shootBullet() {
        calcPosition();
        moveBullet();
        drawBullet();
    }
    //this draws the bullet to the canvas
     public void drawBullet() {
        image(bullet, posX, posY, width/20, height/20);
    }

    //method to move the bullet
     public void moveBullet() {
        posX += speed;
    }

    /*
    this method calculates the starting position of the bullet using the players positions and sizes
    the stop variable acts as a switch so the bullet's posX and posY doesn't update with the player thus allowing
    the bullet to only be affected by the moveBullet() method.
    */
     public void calcPosition() {
        if (stop == false) {
            posX = player.posX + 90;
            posY = player.posY + 30;
            stop = true;
        }
    }

    /* THIS METHOD IS DISABLED, DOESN'T REALLY WORK RIGHT NOW BECAUSE OF ConcurrentModificationException
    I am not sure why yet but i think it's because i cant remove an element while iterating the list??
    this method deletes the bullets (for performance sake, its super laggy out there)
    more on how this "works" cough, cough, here https://www.youtube.com/watch?v=IsdZKG9wyBc&list=PLRqwX-V7Uu6Z9hI4mSgx2FlE5w8zvjmEy&index=3
    void deleteBullet() {
        for (Bullet bullet : bullets) {
            if (enemy.isDead()) bullets.remove(bullet); 
        }
    UPDATE: ended up deleting the bullet when the collision is being checked, still keeping this here in case
    i find a way to make it work since it's way more efficient than the way i am currently using
    }*/
}
class Button {
    //vars
    PFont font;
    float posX, posY;
    String text;
    int tColor;

    //constructor
    Button(String f, float x, float y, String t, int s) {
        posX = x;
        posY = y;
        text = t;
        tColor = color(255);
        //font and it's size
        font = createFont(f, s);
    }

    //method to draw the text
     public void drawText() {
        textFont(font);
        //changes the color of the text on mouse hover using the text's X and Y positions
        if (mouseX > posX - 105 && mouseX < posX + 105 && mouseY < posY && mouseY > posY - 80) 
            fill(136,155,192);
        else fill
            (tColor);

        //display the text
        text(text, posX, posY);
    }

     public void mouseInteraction() {
        //changes the value of the stage variable if the button is pressed, thus playing the game
        if (mouseX > menu.play.posX - 105 && mouseX < menu.play.posX + 105 && mouseY < menu.play.posY && mouseY > menu.play.posY - 80 && mousePressed == true) {
            stage = 1;
        }        
        //changes the value of the stage variable if the button is pressed, thus quitting the game
        if (mouseX > menu.quit.posX - 105 && mouseX < menu.quit.posX + 105 && mouseY < menu.quit.posY && mouseY > menu.quit.posY - 80 && mousePressed == true) {
            stage = 2;
        }   
    }
}
class Collider {
    //vars
    float enemyPosX, enemyPosY, bulletPosX, bulletPosY, playerPosX, playerPosY, distanceB, distanceE, minBulletDistance, minEnemyDistance;

    //constructor
    Collider(float m, float e) {
        minBulletDistance = m;
        minEnemyDistance = e;
    }

     public void runColliders() {
        posSetter();
    }

    /*
    this method receives the enemy's and the bullet's positions
    i am terribly sorry for this two loop mess but to be honest i was running out of time and it was the only thing i could think of
    */
     public void posSetter() {
        //enemies position
        for (int i = 0; i < enemies.length; i++) {
            enemyPosX = enemies[i].posX;
            enemyPosY = enemies[i].posY;

            //player position
            playerPosX = player.posX;
            playerPosY = player.posY;

            //bullet position
            for (int k = 0; k < bullets.size(); k++) {
                bulletPosX = bullets.get(k).posX;
                bulletPosY = bullets.get(k).posY;

                //this calculates the distance
                distanceB = dist(bulletPosX, bulletPosY, enemyPosX, enemyPosY);
                //45 was the best number I could found, still it's not perfect
                if (distanceB < minBulletDistance) {
                    //kills the enemy and adds a score point
                    enemies[i].health -= 100;
                    score += 1;
                    //if hit removes the bullet from the canvas
                    bullets.remove(k);
                }
            }
            //checks players and enemies positions, 46 is the players
            distanceE = dist(playerPosX + 46, playerPosY, enemyPosX, enemyPosY);
            //if enemy collides with player it removes 25 life points
            if (distanceE < minEnemyDistance) {
                enemies[i].health = 0.0f;
                player.health -= 25.0f;
                //goes to gameover screen
                if (player.isDead()) stage = 3;
            }
        }
    }
}
/*
What I did here was defaulting the enemy's X position and re-randomizing it's Y position once it gets killed or leaves the canvas,
this allows me to "re-use" the enemy. I chose this approach because I think it's simple and good performance wise
*/
class Enemy {
    //vars
    PImage enemy;
    float posX, posY, speed, health;

    //constructor
    Enemy(String x, float s, float y) {
        enemy = loadImage(x);
        posX = y; //spawn outside the canvas so it animates the entrance
        posY = random(0, height - height/14 - 2); //height/12 because of the size of the sprite
        speed = s;
        health = 100.0f;
    }

     public void spawnEnemy() {
        spawn();
        difficulty();
        move();
    }

     public void spawn() {
        image(enemy, posX, posY, width/14, height/14);
    }

     public void move() {
        //this validates the enemy's health and its X position 
        if (posX >= -(width/14 + 4) && health > 0) {
            posX -= speed;
        }
        else {
            //this code block is responsible for the repetition of the object
            posX = random(1700, 2300);
            posY = random(0, height - height/14 - 4);
            health = 100.0f; 
        }
    }

    //checks if enemy is alive or dead
     public boolean isDead() {
        if (health <= 0) return true;
        else return false;
    }

    //increases the difficulty
     public void difficulty() {
        if (score >= 20) speed = 6;
        else if (score >= 40) speed = 8;
        else if (score >= 60) speed = 10;
        else if (score >= 80) speed = 12;
        else if (score >= 100) speed = 14;
        else if (score >= 120) speed = 16;
        else if (score >= 140) speed = 20;
        else if (score >= 160) speed = 24;
        else if (score >= 180) speed = 26;
        else if (score >= 200) speed = 28;
    }
}
class GameOver {
    //vars
    PFont font;
    String text;
    float posX, posY;
    Button returntomenu;

    //constructor
    GameOver(String f, float x, float y, int s) {
        posX = x;
        posY = y;

        //font and it's size
        font = createFont(f, s);
    }

     public void displayGameOver() {
        textFont(font);
        fill(255, 101, 101);
        text("GAME OVER", posX, posY);
        textSize(64);
        fill(255, 101, 101);
        text("YOUR SCORE WAS " + score, posX, posY + 100);
        fill(255, 101, 101);
        returntomenu = new Button("/data/ThaleahFat.ttf", width/2, 600, "RETURN", 100);
        returntomenu.drawText();
        //interaction for the return button
        if (mouseX > gameover.returntomenu.posX - 105 && mouseX < gameover.returntomenu.posX + 105 && mouseY < gameover.returntomenu.posY && mouseY > gameover.returntomenu.posY - 80 && mousePressed == true) {
            stage = 0;
            score = 0;
            player.health = 100.0f;
        }  
    }
}
class Menu {
    //vars
    Button play, quit;
    PImage bg;
    PFont font;

    //constructor
    Menu(String z) {
        //play button
        play = new Button("/data/ThaleahFat.ttf", width/2, 200, "PLAY", 100);
        //quit button
        quit = new Button("/data/ThaleahFat.ttf", width/2, 825, "QUIT", 100);
        //loads background image
        bg = loadImage(z);
        font = createFont("/data/ThaleahFat.ttf", 200);
    }

     public void drawBackground() {
        //load background image
        background(bg);
    }

     public void drawButtons() {
        play.drawText();
        play.mouseInteraction();
        quit.drawText();
        quit.mouseInteraction();
        fill(85, 85, 255);
        textFont(font);
        text("JFIGHTER", width/2, height/2);
    }
}
//note: some snippets of this code were studied and extracted from: https://stackoverflow.com/questions/60307773/smooth-movement-in-processing
class Player {
    float posX, posY, xSpeed, ySpeed, speedLimit, acceleration, health;
    boolean move_up = false, move_down = false, move_left = false, move_right = false;
    PImage plane;

    //constructor
    Player(float x, float y, String z) {
        //player pos, speed and health
        posX = x;
        posY = y;
        ySpeed = 0.0f; //DO NOT CHANGE
        xSpeed = 0.0f; //DO NOT CHANGE
        health = 100.0f;
        //speed limit and acceleration for the movement
        speedLimit = 5.0f;
        acceleration = 0.20f;
        //loads the player's sprite
        plane = loadImage(z);
    }

    //this method draws the image to the screen
     public void drawPlayer() {
        image(plane, posX, posY, width/11, height/11);
        //player debug
        println("posX: " + posX + " posY: " + posY + "\n" + "speed: " + xSpeed + "\n");
        move();
    }

   //this method receives the pressed input and acts as a switch for the booleans 
     public void pressed(boolean up, boolean down, boolean left, boolean right) {
        if (up) move_up   = true;
        if (down) move_down = true;
        if (left) move_left   = true;
        if (right) move_right = true;
    }

    //this method receives the released input and acts as a switch for the booleans 
     public void released(boolean up, boolean down, boolean left, boolean right) {
        if (up) move_up   = false;
        if (down) move_down = false;
        if (left) move_left   = false;
        if (right) move_right = false;
    }

     public void move() {
        /*
        the use of acceleration helps creating a smoother movement
        the value of the speed when the key is released multiplies by 0.95 so it creates a smooth stoppage slowly reducing the speed
        */
        if (!move_up && !move_down) ySpeed *= 0.95f;
        if (move_up) ySpeed -= acceleration;
        if (move_down) ySpeed += acceleration;

        //limits the speed 
        ySpeed = max(-(speedLimit), min(speedLimit, ySpeed));
        posY += ySpeed;

        //left and right
        if (!move_left && !move_right) xSpeed *= 0.95f;
        if (move_left) xSpeed -= acceleration;
        if (move_right) xSpeed += acceleration;
        
        xSpeed = max(-(speedLimit), min(speedLimit, xSpeed));
        posX += xSpeed;

        //this blocks the player from exiting the canvas
        if (posY < 2) posY = 2;
        if (posY > height - height/11 - 2) posY = height - height/11 - 2;

        if (posX < 2) posX = 2;
        if (posX > width - width/2) posX = width - width/2;
    }

    //this method checks whether the player is dead or not
     public boolean isDead() {
        if (health > 0) return false;
        else return true;
    }
}
class Points {
    //vars
    PFont font;
    float posX, posY;

    Points(String f, float x, float y, int s) {
        posX = x;
        posY = y;

        //font and it's size
        font = createFont(f, s);
    }

     public void displayScore() {
        fill(255);
        textFont(font);
        text("SCORE: " + score, posX, posY);

        //health display
        fill(255, 101, 101);
        text("HEALTH: " + player.health, posX, height - 100);
    }
}


  public void settings() { size(1600, 870);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "JFighter" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
