/* autogenerated by Processing revision 1277 on 2022-01-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class JFighter extends PApplet {

 //graphics lib
int stage = 0; //variable to control the state of the game (menu, gameplay, pause or exiting)
public int score = 0;
Menu menu; 
Player player;
Background background;
public Enemy[] enemies;
public ArrayList<Bullet> bullets = new ArrayList<Bullet>();
Collider collider;

 public void setup() {
    /* size commented out by preprocessor */;
    /* smooth commented out by preprocessor */;
    menu = new Menu("/data/hills.png"); //main menu's class
    player = new Player(50, 435, "/data/player.png"); //players class
    background = new Background("/data/big-hills2.png", 0); //background class
    enemies = new Enemy[10];
    for (int i = 0; i < enemies.length; i++) {
        enemies[i] = new Enemy("/data/enemy_red.png", random(2, 6), random(1700, 2000)); //enemy class
    }
    collider = new Collider(45); //minDistance
}

 public void draw() {
    if (stage == 0) {
        menu.drawBackground();
        menu.drawButtons();
    }
    else if (stage == 1) {
        background.drawScene();
        player.drawPlayer();
        //loops trought the list of bullets and updates them
        for (Bullet bullet : bullets) {
            bullet.shootBullet();
        }
        for (Enemy enemy : enemies) {
            enemy.spawnEnemy();
        }
        collider.runColliders();
    }
    else if (stage == 2) {
        exit();
    }
}

//validates the user input
 public void keyPressed() {
    player.pressed((key == 'w' || key == 'W'), (key == 's' || key == 'S'), (key == 'a' || key == 'A'), (key == 'd' || key == 'D'));
    //each time the user presses space a new bullet is added to the array :)
    if (key == ' ') bullets.add(new Bullet("/data/bullet.png", 25, 100));
}

 public void keyReleased() {
    player.released((key == 'w' || key == 'W'), (key == 's' || key == 'S'), (key == 'a' || key == 'A'), (key == 'd' || key == 'D'));
}
class Background {
    //vars
    PImage bg, mg;
    float posX, posY, scrollOffset;

    //constructor
    Background(String b, float x) {
        scrollOffset = 1.8f;
        bg = loadImage(b);

        //default x for the hills
        posX = x;
    }

     public void drawScene() {
        //draws the background image
        image(bg, posX, 0);
        //debug 
        //println("posX: " + posX + " posY: " + posY + "\n");
        scrollHills();
    }

     public void scrollHills() {
        //while the player moves forward
        if (player.xSpeed > 0) {
            //this creates the illusion of movement by moving the middleground faster than the player
            posX -= player.xSpeed * scrollOffset;

            //this loops the image (the image width is 4800 it's basicly 3 pictures in one), by resetting it's x position once the player hits the limit
            if (posX <= -3200) posX = 0;
        }
    }
}
class Bullet {
    //vars
    PImage bullet;
    float posX, posY, speed, damage;
    boolean stop;

    //constructor
    Bullet(String b, float s, float d) {
        bullet = loadImage(b);
        speed = s;
        damage = d;
    }

     public void shootBullet() {
        calcPosition();
        moveBullet();
        drawBullet();
        //deleteBullet(); this method is being executed at draw
    }
    //this draws the bullet to the canvas
     public void drawBullet() {
        image(bullet, posX, posY, width/20, height/20);
    }

    //method to move the bullet
     public void moveBullet() {
        posX += speed;
    }

    /*
    this method calculates the starting position of the bullet using the players positions and sizes
    the stop variable acts as a switch so the bullet's posX and posY doesn't update with the player thus allowing
    the bullet to only be affected by the moveBullet() method.
    */
     public void calcPosition() {
        if (stop == false) {
            posX = player.posX + 90;
            posY = player.posY + 30;
            stop = true;
        }
    }

    /* THIS METHOD IS DISABLED, DOESN'T REALLY WORK RIGHT NOW BECAUSE OF ConcurrentModificationException
    I am not sure why yet but i think it's because i cant remove an element while iterating the list??
    this method deletes the bullets (for performance sake, its super laggy out there)
    more on how this "works" cough, cough, here https://www.youtube.com/watch?v=IsdZKG9wyBc&list=PLRqwX-V7Uu6Z9hI4mSgx2FlE5w8zvjmEy&index=3
    void deleteBullet() {
        for (Bullet bullet : bullets) {
            if (enemy.isDead()) bullets.remove(bullet); 
        }
    UPDATE: ended up deleting the bullet when the collision is being checked still keeping this here in case
    i found a way to make it work since it's way more efficient than the other way
    }*/
}
class Button {
    //vars
    float posX, posY;
    int tSize;
    String text;
    int tColor;

    //constructor
    Button(float x, float y, String t) {
        posX = x;
        posY = y;
        text = t;
        //text color and text size
        tColor = color(255);
        tSize = 100;
    }

    //method to draw the text
     public void drawText() {
        textSize(tSize);

        //changes the color of the text on mouse hover using the text's X and Y positions
        if (mouseX > posX && mouseX < posX + 210 && mouseY < posY && mouseY > posY - 80) 
            fill(136,155,192);
        else fill
            (tColor);

        text(text, posX, posY);
    }

     public void mouseInteraction() {
        //changes the value of the stage variable if the button is pressed, thus playing the game
        if (mouseX > menu.play.posX && mouseX < menu.play.posX + 210 && mouseY < menu.play.posY && mouseY > menu.play.posY - 80 && mousePressed == true) {
            stage = 1;
        }        
        //changes the value of the stage variable if the button is pressed, thus quitting the game
        if (mouseX > menu.quit.posX && mouseX < menu.quit.posX + 210 && mouseY < menu.quit.posY && mouseY > menu.quit.posY - 80 && mousePressed == true) {
            stage = 2;
        }
        
    }
}
class Collider {
    //vars
    float enemyPosX, enemyPosY, bulletPosX, bulletPosY, distance, minDistance;

    //constructor
    Collider(float m) {
        minDistance = m;
    }

     public void runColliders() {
        posSetter();
    }

    //this methods receives the enemy's and the bullet's positions
     public void posSetter() {
        //enemies position
        for (int i = 0; i < enemies.length; i++) {
            enemyPosX = enemies[i].posX;
            enemyPosY = enemies[i].posY;

            //bullet position
            for (int k = 0; k < bullets.size(); k++) {
                bulletPosX = bullets.get(k).posX;
                bulletPosY = bullets.get(k).posY;

                //this calculates the distance
                distance = dist(bulletPosX, bulletPosY, enemyPosX, enemyPosY);
                //45 was the best number I could found, still it's not perfect
                if (distance < minDistance) {
                    //kills the enemy and adds a score point
                    enemies[i].health -= 100;
                    score += 1;
                    //if hit removes the bullet from the canvas
                    bullets.remove(k);
                }
            }
        }
    }
}
/*
What I did here was defaulting the enemy's X position and re-randomizing it's Y position once it gets killed or leaves the canvas,
this allows me to "re-use" the enemy. I chose this approach because I think it's simple and good performance wise
*/
class Enemy {
    //vars
    PImage enemy;
    float posX, posY, speed, health;

    //constructor
    Enemy(String x, float s, float y) {
        enemy = loadImage(x);
        posX = y; //spawn outside the canvas so it animates the entrance
        posY = random(0, height - height/14 - 2); //height/12 because of the size of the sprite
        speed = s; //i decided to pass the speed in the constructor so i can increase the difficulty over time
        health = 100.0f;
    }

     public void spawnEnemy() {
        spawn();
        move();
    }

     public void spawn() {
        image(enemy, posX, posY, width/14, height/14);
    }

     public void move() {
        //this validates the enemy's health and its X position 
        if (posX >= -(width/14 + 4) && health > 0) {
            posX -= speed;
        }
        else {
            //this code block is responsible for the repetition of the object
            posX = random(1700, 2000);
            posY = random(0, height - height/14 - 4);
            health = 100.0f; 
        }
    }

    //checks if enemy is alive or dead
     public boolean isDead() {
        if (health <= 0) return true;
        else return false;
    }
}
class Menu {
    //vars
    Button play, quit;
    PImage bg;

    //constructor
    Menu(String z) {
        //play button
        play = new Button(700, 200, "PLAY");
        //quit button
        quit = new Button(700, 825, "QUIT");
        //loads background image
        bg = loadImage(z);
    }

     public void drawBackground() {
        //load background image
        background(bg);
    }

     public void drawButtons() {
        play.drawText();
        play.mouseInteraction();
        quit.drawText();
        quit.mouseInteraction();
    }
}
//note: some snippets of this code were studied and extracted from: https://stackoverflow.com/questions/60307773/smooth-movement-in-processing
class Player {
    float posX, posY, xSpeed, ySpeed, speedLimit, acceleration, health;
    boolean move_up = false, move_down = false, move_left = false, move_right = false;
    PImage plane;

    //constructor
    Player(float x, float y, String z) {
        //player pos, speed and health
        posX = x;
        posY = y;
        ySpeed = 0.0f; //DO NOT CHANGE
        xSpeed = 0.0f; //DO NOT CHANGE
        health = 100.0f;
        //speed limit and acceleration for the movement
        speedLimit = 5.0f;
        acceleration = 0.15f;
        //loads the player's sprite
        plane = loadImage(z);
    }

    //this method draws the image to the screen
     public void drawPlayer() {
        image(plane, posX, posY, width/11, height/11);
        //player debug
        println("posX: " + posX + " posY: " + posY + "\n" + "speed: " + xSpeed + "\n");
        move();
    }

   //this method receives the pressed input and acts as a switch for the booleans 
     public void pressed(boolean up, boolean down, boolean left, boolean right) {
        if (up) move_up   = true;
        if (down) move_down = true;
        if (left) move_left   = true;
        if (right) move_right = true;
    }

    //this method receives the released input and acts as a switch for the booleans 
     public void released(boolean up, boolean down, boolean left, boolean right) {
        if (up) move_up   = false;
        if (down) move_down = false;
        if (left) move_left   = false;
        if (right) move_right = false;
    }

     public void move() {
        /*
        the use of acceleration helps creating a smoother movement
        the value of the speed when the key is released multiplies by 0.95 so it creates a smooth stoppage slowly reducing the speed
        */
        if (!move_up && !move_down) ySpeed *= 0.95f;
        if (move_up) ySpeed -= acceleration;
        if (move_down) ySpeed += acceleration;

        //limits the speed 
        ySpeed = max(-(speedLimit), min(speedLimit, ySpeed));
        posY += ySpeed;

        //left and right
        if (!move_left && !move_right) xSpeed *= 0.95f;
        if (move_left) xSpeed -= acceleration;
        if (move_right) xSpeed += acceleration;
        
        xSpeed = max(-(speedLimit), min(speedLimit, xSpeed));
        posX += xSpeed;

        //this blocks the player from exiting the canvas
        if (posY < 2) posY = 2;
        if (posY > height - height/11 - 2) posY = height - height/11 - 2;

        if (posX < 2) posX = 2;
        if (posX > width - width/2 - 100) posX = width - width/2 - 100;
    }
}


  public void settings() { size(1600, 870);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "JFighter" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
